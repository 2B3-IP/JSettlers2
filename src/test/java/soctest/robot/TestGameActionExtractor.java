/**
 * Java Settlers - An online multiplayer version of the game Settlers of Catan
 * This file Copyright (C) 2021 Jeremy D Monin <jeremy@nand.net>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * The maintainer of this program can be reached at jsettlers@nand.net
 **/

package soctest.robot;

import java.text.ParseException;
import java.util.List;

import soc.extra.robot.GameActionExtractor;
import soc.extra.robot.GameActionLog;
import soc.extra.robot.GameActionLog.Action.ActionType;
import soc.extra.server.GameEventLog;
import soc.extra.server.GameEventLog.QueueEntry;
import soc.game.SOCGame;
import soc.game.SOCPlayingPiece;
import soc.game.SOCResourceSet;
import soc.message.SOCGameServerText;
import soc.message.SOCGameState;
import soc.message.SOCMessage;
import soc.message.SOCNewGame;
import soc.message.SOCPutPiece;
import soc.message.SOCRollDiceRequest;
import soc.message.SOCStartGame;
import soc.message.SOCTurn;
import soc.message.SOCVersion;
import soc.util.Version;

import org.junit.Test;
import static org.junit.Assert.*;

/**
 * A few tests for {@link GameActionLog} and {@link GameActionExtractor}.
 *<P>
 * Extends {@code GameActionExtractor} as an easy way to access its methods being tested.
 *
 * @since 2.5.00
 */
public class TestGameActionExtractor
    extends GameActionExtractor
{
    public TestGameActionExtractor()
    {
        super(makeEmptyEventLog(), true);
    }

    /** Number of event log entries generated by {@link #makeEmptyEventLog()}. */
    private static final int EMPTYEVENTLOG_SIZE_TO_STARTGAME = 4;

    /** Game state at end of event sequence from {@link #makeEmptyEventLog()}. */
    private static final int EMPTYEVENTLOG_STARTGAME_GAME_STATE = SOCGame.START1A;

    /** Create an event log with the minimal required entries. */
    private static GameEventLog makeEmptyEventLog()
    {
        GameEventLog log = new GameEventLog();
        log.add(new QueueEntry(new SOCVersion
            (Version.versionNumber(), Version.version(), "-", null, null), -1, false));
        log.add(new QueueEntry(new SOCNewGame("test"), -1, false));
        log.add(new QueueEntry("Extractor expects to see version, newgame, and startgame"));
        log.add(new QueueEntry(new SOCStartGame("test", EMPTYEVENTLOG_STARTGAME_GAME_STATE), -1, false));

        return log;
    }

    /**
     * Test basic extractor read methods {@code next()}, {@code pushbackTo(...)}, {@code nextIfType()},
     * and {@code resetCurrentSequence()}.
     */
    @Test
    public void testBasicsReadEvents()
        throws ParseException
    {
        final List<QueueEntry> events = eventLog.entries;

        // check contents from makeEmptyEventLog() ran through GameActionExtractor constructor
        assertEquals(4, EMPTYEVENTLOG_SIZE_TO_STARTGAME);
        assertEquals(4, events.size());
        assertEquals(1, actLog.size());
        assertEquals(ActionType.LOG_START_TO_STARTGAME, actLog.get(0).actType);
        assertEquals(4, actLog.get(0).eventSequence.size());
        assertEquals(-1, state.currentPlayerNumber);
        assertEquals(EMPTYEVENTLOG_STARTGAME_GAME_STATE, state.currentGameState);  // was read in next() from SOCStartGame
        assertTrue("at end of event log so far", state.nextLogIndex == events.size());
        assertEquals(4, currentSequenceStartIndex);
        assertEquals(0, currentSequence.size());
        assertNull(next());  // at end of log

        // add a few entries
        events.add(new QueueEntry(new SOCGameState("test", SOCGame.START1B), -1, false));
        events.add(new QueueEntry("next() ignores comments"));
        events.add(new QueueEntry(new SOCPutPiece("test", 3, SOCPlayingPiece.SETTLEMENT, 11), -1, false));
        events.add(new QueueEntry(new SOCGameServerText("test", "should ignore during next()"), -1, false));
        events.add(new QueueEntry(new SOCTurn("test", 3, SOCGame.ROLL_OR_CARD), -1, false));

        // read through those:

        // gamestate(START1B):
        QueueEntry e = next();
        assertNotNull(e);
        assertTrue(e.event instanceof SOCGameState);
        assertEquals(1, currentSequence.size());
        assertEquals(SOCGame.START1B, state.currentGameState);
        assertTrue(currentSequence.get(0).event instanceof SOCGameState);
        assertEquals(5, state.nextLogIndex);

        // comment, SOCPutPiece:
        e = next();
        assertNotNull(e);
        assertTrue(e.event instanceof SOCPutPiece);
        assertEquals(3, currentSequence.size());
        assertTrue(currentSequence.get(1).comment.equals("next() ignores comments"));
        assertTrue(currentSequence.get(2).event instanceof SOCPutPiece);
        assertEquals(7, state.nextLogIndex);

        ExtractorState presentState = new GameActionExtractor.ExtractorState(state);
        assertEquals(SOCGame.START1B, presentState.currentGameState);
        assertEquals(currentSequence.size(), presentState.currentSequenceSize);
        assertEquals(state.nextLogIndex, presentState.nextLogIndex);

        // gameservertext, SOCTurn: Test next, backtrack, next
        for (int i = 0; i <= 1; ++i)
        {
            e = next();
            assertNotNull(e);
            assertTrue(e.event instanceof SOCTurn);
            assertEquals(5, currentSequence.size());
            assertTrue(currentSequence.get(3).event instanceof SOCGameServerText);
            assertTrue(currentSequence.get(4).event instanceof SOCTurn);
            assertEquals(9, state.nextLogIndex);
            assertEquals(3, state.currentPlayerNumber);
            assertEquals(SOCGame.ROLL_OR_CARD, state.currentGameState);

            if (i == 0)
            {
                backtrackTo(presentState);

                assertEquals(3, currentSequence.size());
                assertEquals(7, state.nextLogIndex);
                assertEquals(-1, state.currentPlayerNumber);
                assertEquals(SOCGame.START1B, state.currentGameState);
            }
        }

        assertTrue("at end of event log so far", state.nextLogIndex == events.size());

        // add another entry, test nextIfType:

        events.add(new QueueEntry(new SOCRollDiceRequest("test"), -1, false));

        e = nextIfType(SOCMessage.BANKTRADE);
        assertNull(e);
        assertEquals(9, state.nextLogIndex);

        e = nextIfType(SOCMessage.ROLLDICEREQUEST);
        assertNotNull(e);
        assertTrue(e.event instanceof SOCRollDiceRequest);
        assertEquals(6, currentSequence.size());
        assertTrue(currentSequence.get(5).event instanceof SOCRollDiceRequest);
        assertEquals(10, state.nextLogIndex);

        // resetCurrentSequence
        List<QueueEntry> seq = resetCurrentSequence();
        assertEquals(6, seq.size());
        assertEquals(0, currentSequence.size());
        assertEquals(10, currentSequenceStartIndex);
        assertEquals(10, state.nextLogIndex);
    }

    /**
     * Test extraction of a turn where pieces are built:
     * {@link ActionType#TURN_BEGINS}, {@link ActionType#ROLL_DICE} with gains,
     * {@link ActionType#BUILD_PIECE} x 2, {@link ActionType#END_TURN}.
     * Sequences based on {@code all-basic-actions.soclog}.
     */
    @Test
    public void testTurnWithBuilding()
    {
        final List<QueueEntry> events = eventLog.entries;

        // check contents from makeEmptyEventLog() ran through GameActionExtractor constructor
        assertEquals(EMPTYEVENTLOG_SIZE_TO_STARTGAME, events.size());
        assertEquals(1, actLog.size());
        assertEquals(ActionType.LOG_START_TO_STARTGAME, actLog.get(0).actType);
        assertEquals(EMPTYEVENTLOG_SIZE_TO_STARTGAME, actLog.get(0).eventSequence.size());
        assertEquals(-1, state.currentPlayerNumber);
        assertEquals(EMPTYEVENTLOG_STARTGAME_GAME_STATE, state.currentGameState);  // was read in next() from SOCStartGame
        assertTrue("at end of event log so far", state.nextLogIndex == events.size());
        assertEquals(EMPTYEVENTLOG_SIZE_TO_STARTGAME, currentSequenceStartIndex);
        assertEquals(0, currentSequence.size());
        assertNull(next());  // at end of log

        for (String event : new String[] {
            // start of turn:
            "all:SOCPlayerElement:game=test|playerNum=3|actionType=SET|elementType=19|amount=0",
            "all:SOCTurn:game=test|playerNumber=3|gameState=15",
            "all:SOCRollDicePrompt:game=test|playerNumber=3",

            // roll dice:
            "f3:SOCRollDice:game=test",
            "all:SOCDiceResult:game=test|param=8",
            "all:SOCDiceResultResources:game=test|p=1|p=3|p=8|p=1|p=1",
            "p3:SOCPlayerElements:game=test|playerNum=3|actionType=SET|e1=1,e2=2,e3=1,e4=3,e5=1",
            "all:SOCGameState:game=test|state=20",

            // build piece starting with buildrequest:
            "f3:SOCBuildRequest:game=test|pieceType=3",
            "all:SOCPlayerElements:game=test|playerNum=3|actionType=LOSE|e3=1,e5=1",
            "all:SOCGameState:game=test|state=35",
            "f3:SOCPutPiece:game=test|playerNumber=3|pieceType=3|coord=602",
            "all:SOCGameServerText:game=test|text=p3 built a ship.",
            "all:SOCPutPiece:game=test|playerNumber=3|pieceType=3|coord=602",
            "all:SOCGameState:game=test|state=20",

            // build piece starting with putpiece:
            "f3:SOCPutPiece:game=test|playerNumber=3|pieceType=1|coord=804",
            "all:SOCPlayerElements:game=test|playerNum=3|actionType=LOSE|e1=1,e3=1,e4=1,e5=1",
            "all:SOCGameServerText:game=test|text=p3 built a settlement.",
            "all:SOCPutPiece:game=test|playerNumber=3|pieceType=1|coord=804",
            "all:SOCGameState:game=test|state=20",

            // end turn:
            "f3:SOCEndTurn:game=test",
            "all:SOCClearOffer:game=test|playerNumber=-1",
            })
            try {
                events.add(QueueEntry.parse(event));
            } catch (ParseException e) {
                fail("Internal error: ParseException for \"" + event + "\": " + e.getMessage());
            }

        final GameActionLog actionLog = extract();

        assertEquals("at end of event log", events.size(), state.nextLogIndex);
        assertNull(next());  // at end of log again
        assertNotNull(actionLog);
        assertEquals(6, actionLog.size());

        GameActionLog.Action act = actionLog.get(0);
        assertEquals(ActionType.LOG_START_TO_STARTGAME, act.actType);
        assertEquals(EMPTYEVENTLOG_SIZE_TO_STARTGAME, act.eventSequence.size());
        assertEquals(EMPTYEVENTLOG_STARTGAME_GAME_STATE, act.endingGameState);

        act = actionLog.get(1);
        assertEquals(ActionType.TURN_BEGINS, act.actType);
        assertEquals(3, act.eventSequence.size());
        assertEquals(SOCGame.ROLL_OR_CARD, act.endingGameState);
        assertEquals("new current player number", 3, act.param1);

        act = actionLog.get(2);
        assertEquals(ActionType.ROLL_DICE, act.actType);
        assertEquals(5, act.eventSequence.size());
        assertEquals(SOCGame.PLAY1, act.endingGameState);
        assertEquals("dice roll sum", 8, act.param1);

        act = actionLog.get(3);
        assertEquals(ActionType.BUILD_PIECE, act.actType);
        assertEquals(7, act.eventSequence.size());
        assertEquals(SOCGame.PLAY1, act.endingGameState);
        assertEquals("built ship", SOCPlayingPiece.SHIP, act.param1);
        assertEquals("built at 0x602", 0x602, act.param2);
        assertEquals("built by player 3", 3, act.param3);

        act = actionLog.get(4);
        assertEquals(ActionType.BUILD_PIECE, act.actType);
        assertEquals(5, act.eventSequence.size());
        assertEquals(SOCGame.PLAY1, act.endingGameState);
        assertEquals("built settlement", SOCPlayingPiece.SETTLEMENT, act.param1);
        assertEquals("built at 0x804", 0x804, act.param2);
        assertEquals("built by player 3", 3, act.param3);

        act = actionLog.get(5);
        assertEquals(ActionType.END_TURN, act.actType);
        assertEquals(2, act.eventSequence.size());
        assertEquals(SOCGame.PLAY1, act.endingGameState);
    }

    /**
     * Test extraction of a turn with bank trades and player trades:
     * {@link ActionType#TURN_BEGINS}, {@link ActionType#ROLL_DICE} without gains,
     * {@link ActionType#TRADE_BANK}, {@link ActionType#TRADE_MAKE_OFFER},
     * {@link ActionType#TRADE_REJECT_OFFER}, {@link ActionType#TRADE_ACCEPT_OFFER},
     * {@link ActionType#END_TURN}.
     * Sequences based on {@code all-basic-actions.soclog}.
     */
    @Test
    public void testBankTradePlayerTrade()
    {
        final List<QueueEntry> events = eventLog.entries;

        // check contents from makeEmptyEventLog() ran through GameActionExtractor constructor
        assertEquals(EMPTYEVENTLOG_SIZE_TO_STARTGAME, events.size());
        assertEquals(1, actLog.size());
        assertEquals(ActionType.LOG_START_TO_STARTGAME, actLog.get(0).actType);
        assertEquals(EMPTYEVENTLOG_SIZE_TO_STARTGAME, actLog.get(0).eventSequence.size());
        assertEquals(-1, state.currentPlayerNumber);
        assertEquals(EMPTYEVENTLOG_STARTGAME_GAME_STATE, state.currentGameState);  // was read in next() from SOCStartGame
        assertTrue("at end of event log so far", state.nextLogIndex == events.size());
        assertEquals(EMPTYEVENTLOG_SIZE_TO_STARTGAME, currentSequenceStartIndex);
        assertEquals(0, currentSequence.size());
        assertNull(next());  // at end of log

        for (String event : new String[] {
            // start of turn:
            "all:SOCPlayerElement:game=test|playerNum=3|actionType=SET|elementType=19|amount=0",
            "all:SOCTurn:game=test|playerNumber=3|gameState=15",
            "all:SOCRollDicePrompt:game=test|playerNumber=3",

            // roll dice:
            "f3:SOCRollDice:game=test",
            "all:SOCDiceResult:game=test|param=12",
            "all:SOCGameServerText:game=test|text=No player gets anything.",
            "all:SOCGameState:game=test|state=20",

            // bank trade:
            "f3:SOCBankTrade:game=test|give=clay=0|ore=3|sheep=0|wheat=0|wood=0|unknown=0|get=clay=1|ore=0|sheep=0|wheat=0|wood=0|unknown=0",
            "all:SOCBankTrade:game=test|give=clay=0|ore=3|sheep=0|wheat=0|wood=0|unknown=0|get=clay=1|ore=0|sheep=0|wheat=0|wood=0|unknown=0|pn=3",

            // undo bank trade:
            "f3:SOCBankTrade:game=test|give=clay=1|ore=0|sheep=0|wheat=0|wood=0|unknown=0|get=clay=0|ore=3|sheep=0|wheat=0|wood=0|unknown=0",
            "all:SOCBankTrade:game=test|give=clay=1|ore=0|sheep=0|wheat=0|wood=0|unknown=0|get=clay=0|ore=3|sheep=0|wheat=0|wood=0|unknown=0|pn=3",

            // player p3 make trade offer to players:
            "f3:SOCMakeOffer:game=test|offer=game=test|from=3|to=false,true,true,false|give=clay=0|ore=0|sheep=0|wheat=0|wood=1|unknown=0|get=clay=0|ore=1|sheep=0|wheat=0|wood=0|unknown=0",
            "all:SOCMakeOffer:game=test|offer=game=test|from=3|to=false,true,true,false|give=clay=0|ore=0|sheep=0|wheat=0|wood=1|unknown=0|get=clay=0|ore=1|sheep=0|wheat=0|wood=0|unknown=0",
            "all:SOCClearTradeMsg:game=test|playerNumber=-1",

            // p1 rejects:
            "f1:SOCRejectOffer:game=test|playerNumber=0",
            "all:SOCRejectOffer:game=test|playerNumber=1",

            // p2 accepts:
            "f2:SOCAcceptOffer:game=test|accepting=0|offering=3",
            "all:SOCAcceptOffer:game=test|accepting=2|offering=3|toAccepting=clay=0|ore=0|sheep=0|wheat=0|wood=1|unknown=0|toOffering=clay=0|ore=1|sheep=0|wheat=0|wood=0|unknown=0",
            "all:SOCClearOffer:game=test|playerNumber=-1",

            // end turn:
            "f3:SOCEndTurn:game=test",
            "all:SOCClearOffer:game=test|playerNumber=-1",
            })
            try {
                events.add(QueueEntry.parse(event));
            } catch (ParseException e) {
                fail("Internal error: ParseException for \"" + event + "\": " + e.getMessage());
            }

        final GameActionLog actionLog = extract();

        assertEquals("at end of event log", events.size(), state.nextLogIndex);
        assertNull(next());  // at end of log again
        assertNotNull(actionLog);
        assertEquals(9, actionLog.size());

        GameActionLog.Action act = actionLog.get(0);
        assertEquals(ActionType.LOG_START_TO_STARTGAME, act.actType);
        assertEquals(EMPTYEVENTLOG_SIZE_TO_STARTGAME, act.eventSequence.size());
        assertEquals(EMPTYEVENTLOG_STARTGAME_GAME_STATE, act.endingGameState);

        act = actionLog.get(1);
        assertEquals(ActionType.TURN_BEGINS, act.actType);
        assertEquals(3, act.eventSequence.size());
        assertEquals(SOCGame.ROLL_OR_CARD, act.endingGameState);
        assertEquals("new current player number", 3, act.param1);

        act = actionLog.get(2);
        assertEquals(ActionType.ROLL_DICE, act.actType);
        assertEquals(4, act.eventSequence.size());
        assertEquals(SOCGame.PLAY1, act.endingGameState);
        assertEquals("dice roll sum", 12, act.param1);

        act = actionLog.get(3);
        assertEquals(ActionType.TRADE_BANK, act.actType);
        assertEquals(2, act.eventSequence.size());
        assertEquals(SOCGame.PLAY1, act.endingGameState);
        final SOCResourceSet
            ORE_3 = new SOCResourceSet(0, 3, 0, 0, 0, 0),
            CLAY_1 = new SOCResourceSet(1, 0, 0, 0, 0, 0);
        assertEquals("trade in 3 ore", ORE_3, act.rset1);
        assertEquals("get 1 clay", CLAY_1, act.rset2);

        act = actionLog.get(4);
        assertEquals(ActionType.TRADE_BANK, act.actType);
        assertEquals(2, act.eventSequence.size());
        assertEquals(SOCGame.PLAY1, act.endingGameState);
        assertEquals("trade back 1 clay", CLAY_1, act.rset1);
        assertEquals("get 3 ore", ORE_3, act.rset2);

        act = actionLog.get(5);
        assertEquals(ActionType.TRADE_MAKE_OFFER, act.actType);
        assertEquals(3, act.eventSequence.size());
        assertEquals(SOCGame.PLAY1, act.endingGameState);
        final SOCResourceSet
           WOOD_1 = new SOCResourceSet(0, 0, 0, 0, 1, 0),
           ORE_1 = new SOCResourceSet(0, 1, 0, 0, 0, 0);
        assertEquals("offer to give 1 wood", WOOD_1, act.rset1);
        assertEquals("to get 1 ore", ORE_1, act.rset2);
        assertEquals("player 3 offering", 3, act.param1);

        act = actionLog.get(6);
        assertEquals(ActionType.TRADE_REJECT_OFFER, act.actType);
        assertEquals(2, act.eventSequence.size());
        assertEquals(SOCGame.PLAY1, act.endingGameState);
        assertEquals("player 1 rejecting", 1, act.param1);

        act = actionLog.get(7);
        assertEquals(ActionType.TRADE_ACCEPT_OFFER, act.actType);
        assertEquals(3, act.eventSequence.size());
        assertEquals(SOCGame.PLAY1, act.endingGameState);
        assertEquals("gave 1 wood", WOOD_1, act.rset1);
        assertEquals("to get 1 ore", ORE_1, act.rset2);
        assertEquals("player 3 offering", 3, act.param1);
        assertEquals("player 2 accepting", 2, act.param2);

        act = actionLog.get(8);
        assertEquals(ActionType.END_TURN, act.actType);
        assertEquals(2, act.eventSequence.size());
        assertEquals(SOCGame.PLAY1, act.endingGameState);
    }

    /**
     * Test extraction of a turn with rolling 7, players discard, move robber, rob,
     * play Knight/Soldier dev card, choose victim, rob:
     * {@link ActionType#TURN_BEGINS}, {@link ActionType#ROLL_DICE}, {@link ActionType#DISCARD},
     * {@link ActionType#MOVE_ROBBER_OR_PIRATE}, {@link ActionType#ROB_PLAYER},
     * {@link ActionType#PLAY_DEV_CARD}, {@link ActionType#CHOOSE_ROBBERY_VICTIM},
     * {@link ActionType#ROB_PLAYER}, {@link ActionType#END_TURN}.
     */
    @Test
    public void testRoll7DiscardsMoveRobberSteal()
    {
        final List<QueueEntry> events = eventLog.entries;

        // check contents from makeEmptyEventLog() ran through GameActionExtractor constructor
        assertEquals(EMPTYEVENTLOG_SIZE_TO_STARTGAME, events.size());
        assertEquals(1, actLog.size());
        assertEquals(ActionType.LOG_START_TO_STARTGAME, actLog.get(0).actType);
        assertEquals(EMPTYEVENTLOG_SIZE_TO_STARTGAME, actLog.get(0).eventSequence.size());
        assertEquals(-1, state.currentPlayerNumber);
        assertEquals(EMPTYEVENTLOG_STARTGAME_GAME_STATE, state.currentGameState);  // was read in next() from SOCStartGame
        assertTrue("at end of event log so far", state.nextLogIndex == events.size());
        assertEquals(EMPTYEVENTLOG_SIZE_TO_STARTGAME, currentSequenceStartIndex);
        assertEquals(0, currentSequence.size());
        assertNull(next());  // at end of log

        for (String event : new String[] {
            // start of turn:
            "all:SOCPlayerElement:game=test|playerNum=3|actionType=SET|elementType=19|amount=0",
            "all:SOCTurn:game=test|playerNumber=3|gameState=15",
            "all:SOCRollDicePrompt:game=test|playerNumber=3",

            // roll dice: 2 players must discard (p1, p3)
            "f3:SOCRollDice:game=test",
            "all:SOCDiceResult:game=test|param=7",
            "all:SOCGameState:game=test|state=50",
            "all:SOCGameServerText:game=test|text=p1 and p3 need to discard.",
            "p1:SOCDiscardRequest:game=test|numDiscards=6",
            "p3:SOCDiscardRequest:game=test|numDiscards=9",

            // p1 discards:
            "f1:SOCDiscard:game=test|resources=clay=0|ore=0|sheep=3|wheat=1|wood=2|unknown=0",
            "p1:SOCPlayerElement:game=test|playerNum=1|actionType=LOSE|elementType=3|amount=3",
            "p1:SOCPlayerElement:game=test|playerNum=1|actionType=LOSE|elementType=4|amount=1",
            "p1:SOCPlayerElement:game=test|playerNum=1|actionType=LOSE|elementType=5|amount=2",
            "!p1:SOCPlayerElement:game=test|playerNum=1|actionType=LOSE|elementType=6|amount=6|news=Y",

            // these are from p1 discard, but since extractor ignores SOCGameServerText
            // they'll be included as part of next sequence:
            "all:SOCGameServerText:game=test|text=p1 discarded 6 resources.",
            "all:SOCGameServerText:game=test|text=p3 needs to discard.",

            // p3 discards:
            "f3:SOCDiscard:game=test|resources=clay=0|ore=2|sheep=2|wheat=2|wood=3|unknown=0",
            "p3:SOCPlayerElement:game=test|playerNum=3|actionType=LOSE|elementType=2|amount=2",
            "p3:SOCPlayerElement:game=test|playerNum=3|actionType=LOSE|elementType=3|amount=2",
            "p3:SOCPlayerElement:game=test|playerNum=3|actionType=LOSE|elementType=4|amount=2",
            "p3:SOCPlayerElement:game=test|playerNum=3|actionType=LOSE|elementType=5|amount=3",
            "!p3:SOCPlayerElement:game=test|playerNum=3|actionType=LOSE|elementType=6|amount=9|news=Y",
            "all:SOCGameServerText:game=test|text=p3 discarded 9 resources.",
            "all:SOCGameState:game=test|state=33",

            // move robber:
            "all:SOCGameServerText:game=test|text=p3 will move the robber.",
            "f3:SOCMoveRobber:game=test|playerNumber=3|coord=b9",
            "all:SOCMoveRobber:game=test|playerNumber=3|coord=b9",

            // rob player 2:
            "p3:SOCReportRobbery:game=test|perp=3|victim=2|resType=5|amount=1|isGainLose=true",
            "p2:SOCReportRobbery:game=test|perp=3|victim=2|resType=5|amount=1|isGainLose=true",
            "!p[3, 2]:SOCReportRobbery:game=test|perp=3|victim=2|resType=6|amount=1|isGainLose=true",
            "all:SOCGameState:game=test|state=20",

            // play Soldier dev card:
            "f3:SOCPlayDevCardRequest:game=test|devCard=9",
            "all:SOCGameServerText:game=test|text=p3 played a Soldier card.",
            "all:SOCDevCardAction:game=test|playerNum=3|actionType=PLAY|cardType=9",
            "all:SOCPlayerElement:game=test|playerNum=3|actionType=SET|elementType=19|amount=1",
            "all:SOCPlayerElement:game=test|playerNum=3|actionType=GAIN|elementType=15|amount=1",
            "all:SOCGameState:game=test|state=33",

            // these are from dev card, but since extractor ignores SOCGameServerText
            // they'll be included as part of next sequence:

            "all:SOCGameServerText:game=test|text=p3 will move the robber.",

            // move robber:
            "f3:SOCMoveRobber:game=test|playerNumber=3|coord=75",
            "all:SOCMoveRobber:game=test|playerNumber=3|coord=75",
            "all:SOCGameServerText:game=test|text=p3 moved the robber. Must choose a victim.",
            "all:SOCGameState:game=test|state=51",

            // choose victim:
            "p3:SOCChoosePlayerRequest:game=test|choices=[false, true, true, false]",
            "f3:SOCChoosePlayer:game=test|choice=1",

            // rob player 1:
            "p3:SOCReportRobbery:game=test|perp=3|victim=1|resType=2|amount=1|isGainLose=true",
            "p1:SOCReportRobbery:game=test|perp=3|victim=1|resType=2|amount=1|isGainLose=true",
            "!p[3, 1]:SOCReportRobbery:game=test|perp=3|victim=1|resType=6|amount=1|isGainLose=true",
            "all:SOCGameState:game=test|state=20",

            // end turn:
            "f3:SOCEndTurn:game=test",
            "all:SOCClearOffer:game=test|playerNumber=-1",
            })
            try {
                events.add(QueueEntry.parse(event));
            } catch (ParseException e) {
                fail("Internal error: ParseException for \"" + event + "\": " + e.getMessage());
            }

        final GameActionLog actionLog = extract();

        assertEquals("at end of event log", events.size(), state.nextLogIndex);
        assertNull(next());  // at end of log again
        assertNotNull(actionLog);
        assertEquals(12, actionLog.size());

        GameActionLog.Action act = actionLog.get(0);
        assertEquals(ActionType.LOG_START_TO_STARTGAME, act.actType);
        assertEquals(EMPTYEVENTLOG_SIZE_TO_STARTGAME, act.eventSequence.size());
        assertEquals(EMPTYEVENTLOG_STARTGAME_GAME_STATE, act.endingGameState);

        act = actionLog.get(1);
        assertEquals(ActionType.TURN_BEGINS, act.actType);
        assertEquals(3, act.eventSequence.size());
        assertEquals(SOCGame.ROLL_OR_CARD, act.endingGameState);
        assertEquals("new current player number", 3, act.param1);

        act = actionLog.get(2);
        assertEquals(ActionType.ROLL_DICE, act.actType);
        assertEquals(6, act.eventSequence.size());
        assertEquals(SOCGame.WAITING_FOR_DISCARDS, act.endingGameState);
        assertEquals("dice roll sum", 7, act.param1);

        act = actionLog.get(3);
        assertEquals(ActionType.DISCARD, act.actType);
        assertEquals(5, act.eventSequence.size());
        assertEquals(SOCGame.WAITING_FOR_DISCARDS, act.endingGameState);

        act = actionLog.get(4);
        assertEquals(ActionType.DISCARD, act.actType);
        assertEquals(10, act.eventSequence.size());
        assertEquals(SOCGame.PLACING_ROBBER, act.endingGameState);

        act = actionLog.get(5);
        assertEquals(ActionType.MOVE_ROBBER_OR_PIRATE, act.actType);
        assertEquals(3, act.eventSequence.size());
        assertEquals(SOCGame.PLACING_ROBBER, act.endingGameState);

        act = actionLog.get(6);
        assertEquals(ActionType.ROB_PLAYER, act.actType);
        assertEquals(4, act.eventSequence.size());
        assertEquals(SOCGame.PLAY1, act.endingGameState);

        act = actionLog.get(7);
        assertEquals(ActionType.PLAY_DEV_CARD, act.actType);
        assertEquals(6, act.eventSequence.size());
        assertEquals(SOCGame.PLACING_ROBBER, act.endingGameState);

        act = actionLog.get(8);
        assertEquals(ActionType.MOVE_ROBBER_OR_PIRATE, act.actType);
        assertEquals(5, act.eventSequence.size());
        assertEquals(SOCGame.WAITING_FOR_ROB_CHOOSE_PLAYER, act.endingGameState);

        act = actionLog.get(9);
        assertEquals(ActionType.CHOOSE_ROBBERY_VICTIM, act.actType);
        assertEquals(2, act.eventSequence.size());
        assertEquals(SOCGame.WAITING_FOR_ROB_CHOOSE_PLAYER, act.endingGameState);

        act = actionLog.get(10);
        assertEquals(ActionType.ROB_PLAYER, act.actType);
        assertEquals(4, act.eventSequence.size());
        assertEquals(SOCGame.PLAY1, act.endingGameState);

        act = actionLog.get(11);
        assertEquals(ActionType.END_TURN, act.actType);
        assertEquals(2, act.eventSequence.size());
        assertEquals(SOCGame.PLAY1, act.endingGameState);
    }

}
